; Namespace macro named 'ns' (unevaluated) and creates namespace if needed.
(ns com.solobit.clojure.practice.showcase
  
  ; Meta-data =^{key & keys}= to append and be used by other applications.
  ^{:doc "These are some early experiments with the language Clojure, and
    the first serious attempts at learning a Lisp. I made this using LightTable
    and Emacs on my Arch Linux distro running Xmonad window manager."
    :author "Rob Jentzema"
    :since "1.0"}
  
  
  ; For each name in class-name-symbols, adds a mapping from name to the
  ; class named by package.name to the =current= namespace.
  (:import (java.lang.Math)
           (java.lang.Date))
  
  (:require [clojure.repl :as repl :only doc])) ; End of macro paren(thesis)


;; We are still in the scope of our namespace, now loaded with additional
;; libraries and packages. We may easily use them now. The :only key is used
;; to limit what we map/import so we are sparse with memory.

(str (Date.))

;; More proof that we're in our namespace and can use these functions?
(str (def *proof* (Date.)))

;; Loads libs, skipping any that are already loaded. Each argument is either a libspec that identifies a lib, a prefix list that identifies multiple libs whose names share a common prefix, or a flag that modifies how all the identified libs are loaded. Use :require in the ns macro in preference to calling this directly.
'(require '(clojure [repl :as repl :only [doc]]))
;; NOTE that the syntax is different

;; Use :import in the ns macro in preference to calling this directly.
'(import '(java.lang.Math))
;; Literal one line above won't interfere and illustrates better in LT than comments....

;;'This will fail so I see the semi-colon isn't doing the wrapping of characters
;; We need either double quotes "like this" or (wrap inside parens)
'(So this does work)
'(And even with a :key so we get color matches)
'"These are also valid ways to show a literal"

;; Now it gets more fun
''hello'
;''hello world ;<= exception
;; So single quotes don't work like any other language most of the time do
;; 'this is not a string literal' "neither is this" because ' is a symbol???













(def *now* (Date.))
(str *now*)


; We have a board game area, let it be a perfect square of 
; four (4) equally sized blocks
; where each block has
;   six (6) slots (|)

; ------ ------
;
; |||||| ||||||
; 
; |||||| |||||| 
; (slots represented by | which are pidgeon holes)


; since we have two players maximum and no two players may occupy a slot
; a slot can be seen as a one-dimensional number line of positive and negative integers
(list -5 -4 -3 -2 -1 0 1 2 3 4 5)

; A single box, of six slots, can thus be seen as
(list 0 0 0 0 0 0)

; let player1, p1 be positive, neg AND have 15 pieces
; let player2, p2 be negative, pos AND have 15 pieces

; We would represent each of the four boxes when (partially filled)
(defn box [] '(0 -1 -2 0 -3 -2))

; But we know this isn't the whole picture

(seq? box) ; !

(box)
; so
(seq? (box))
; then count works on a sequence
(count (box))


; because this is the maximum number of pieces allowed on 1 field
; since no fields can be occupied by more then 1 player, we can
; use negative real numbers, integers to represent pieces in a slot
; and because the total players is always two, use addition and
; subtraction to mutate the state of the board


; define 2 variable pieces
(def p1-pieces (repeatedly 15 #(atom nil)))
(def p2-pieces (repeatedly 15 #(atom nil)))

;(defn update-stack [new-amount] (reset! p1-pieces new-amount))

(def board (atom '(0 0 0 0 0 0)))
(println @board)

;(repl/doc atom)


(list 1 2 3)

(list* 1 2 '(3 4 5)) ; last arg in list is sequence to append
  
  
(defn roll [player dice] 
  
  "Roll n amount of dices each with 6 sides and equally numbered values on them.
  The lowest value should always come out first."  
  
  (sort (repeatedly dice #(+ (rand-int 6) 1))))




(repeatedly 15 #(seq nil))


;(println (cons 1 2))

;(repeatedly 5 (roll 2))
(roll 1 2)



;(repeat '(nil) 4)